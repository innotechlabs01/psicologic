// routes/paymentRoutes.js
import express from "express";
import User from "../../models/user.js";
import Payment from "../../models/payment.js";
import { authenticate } from "../../middlewares/auth.js";

const router = express.Router();

// ===== Endpoints de pagos espec√≠ficos =====

router.get("/payment-status/:paymentId", authenticate, async (req, res) => {
  try {
    const { paymentId } = req.params;
    console.log(`üìç Buscando informaci√≥n del pago: ${paymentId}`);

    const payment = await Payment.findOne({
      where: { paymentId },
      include: [{
        model: User,
        attributes: ['id', 'email', 'name', 'suspense']
      }]
    });

    if (!payment) {
      console.warn(`‚ùå Pago no encontrado: ${paymentId}`);
      return res.status(404).json({
        error: "Pago no encontrado",
        message: "El pago solicitado no existe en el sistema"
      });
    }

    if (payment.userId !== req.user.id && req.user.role !== 'admin') {
      console.warn(`‚ö†Ô∏è Intento de acceso no autorizado al pago ${paymentId} por usuario ${req.user.id}`);
      return res.status(403).json({
        error: "Acceso denegado",
        message: "No tienes permiso para ver este pago"
      });
    }

    const response = {
      id: payment.id,
      paymentId: payment.paymentId,
      status: payment.status,
      amount: payment.amount,
      paymentDate: payment.paymentDate,
      nextPaymentDate: payment.nextPaymentDate,
      blockedPaymentDate: payment.blockedPaymentDate,
      suspense: payment.suspense,
      user: {
        id: payment.User.id,
        email: payment.User.email,
        name: payment.User.name,
        suspense: payment.User.suspense
      }
    };

    console.log(`‚úÖ Consulta exitosa de pago ${paymentId} para usuario ${req.user.id}`);
    res.json(response);
  } catch (err) {
    console.error("‚ùå Error al obtener estado del pago:", err);
    res.status(500).json({
      error: "Error del servidor",
      message: "Hubo un error al procesar tu solicitud"
    });
  }
});

// ===== Endpoints de suscripci√≥n =====

router.get("/status/:userId", authenticate, async (req, res) => {
  try {
    if (req.params.userId != req.user.id && req.user.role !== 'admin') {
      console.warn(`‚ö†Ô∏è Intento de acceso no autorizado a informaci√≥n de usuario ${req.params.userId} por usuario ${req.user.id}`);
      return res.status(403).json({ error: 'No tienes permiso para ver esta informaci√≥n' });
    }

    const user = await User.findOne({
      where: {
        id: req.params.userId
      },
      include: [{
        model: Payment,
        where: {
          status: 'approved'
        },
        required: false,
        order: [['paymentDate', 'DESC']],
        limit: 1
      }]
    });

    console.log('Usuario encontrado para estado de suscripci√≥n:', user ? user.email : 'No encontrado');

    if (!user) {
      return res.status(404).json({ error: 'Usuario no encontrado' });
    }

    if (!user.Payments || user.Payments.length === 0) {
      return res.json({
        status: 'inactive',
        lastPayment: null,
        nextPaymentDate: null,
        expirationDate: null,
        daysRemaining: 0,
        email: user.email,
        name: user.name
      });
    }

    const lastPayment = user.Payments[0];
    const now = new Date();
    const expirationDate = lastPayment.blockedPaymentDate;
    const daysRemaining = Math.ceil((expirationDate - now) / (1000 * 60 * 60 * 24));

    let status = 'active';
    if (daysRemaining <= 5 && daysRemaining > 0) {
      status = 'warning';
    } else if (daysRemaining <= 0) {
      status = 'expired';
    }

    res.json({
      status,
      lastPayment: lastPayment.paymentDate,
      nextPaymentDate: lastPayment.nextPaymentDate,
      expirationDate: lastPayment.blockedPaymentDate,
      daysRemaining: Math.max(0, daysRemaining),
      suspense: lastPayment.suspense,
      email: user.email,
      name: user.name
    });
  } catch (err) {
    console.error("‚ùå Error obteniendo estado del pago:", err);
    res.status(500).json({ error: "Error obteniendo estado del pago" });
  }
});

// ===== Endpoints de historial de pagos =====

router.get("/user/:userId", authenticate, async (req, res) => {
  try {
    const { userId } = req.params;
    
    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ error: "Usuario no encontrado" });
    }

    if (userId != req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'No tienes permiso para ver esta informaci√≥n' });
    }

    const payments = await Payment.findAll({
      where: { userId },
      order: [['paymentDate', 'DESC']]
    });

    res.json(payments);
  } catch (err) {
    console.error("‚ùå Error obteniendo pagos:", err);
    res.status(500).json({ error: "Error obteniendo pagos" });
  }
});

router.get("/:email", authenticate, async (req, res) => {
  try {
    const user = await User.findOne({
      where: { email: req.params.email }
    });

    if (!user) {
      return res.status(404).json({ error: "Usuario no encontrado" });
    }

    if (user.id != req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'No tienes permiso para ver esta informaci√≥n' });
    }

    const payments = await Payment.findAll({
      where: { userId: user.id },
      order: [['paymentDate', 'DESC']]
    });
    
    res.json(payments.length ? payments : []);
  } catch (err) {
    console.error("‚ùå Error obteniendo pagos:", err);
    res.status(500).json({ error: "Error obteniendo pagos" });
  }
});

// ===== Endpoints de creaci√≥n de pagos =====

router.post("/checkout", authenticate, async (req, res) => {
  try {
    const { userId, amount } = req.body;

    if (!userId || !amount) {
      return res.status(400).json({ error: "userId y amount son requeridos" });
    }

    // Verificar permisos
    if (userId != req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'No tienes permiso para realizar esta acci√≥n' });
    }

    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ error: "Usuario no encontrado" });
    }

    const preference = {
      items: [
        {
          title: "Suscripci√≥n mensual",
          unit_price: Number(amount),
          quantity: 1,
        },
      ],
      back_urls: {
        success: process.env.MP_SUCCESS_URL || "http://localhost:3000/success",
        failure: process.env.MP_FAILURE_URL || "http://localhost:3000/failure",
        pending: process.env.MP_PENDING_URL || "http://localhost:3000/pending",
      },
      auto_return: "approved",
      payer: {
        email: user.email,
      },
    };
    
    const { client } = req.app.locals.mercadopago;
    const response = await client.create({ body: preference });

    res.json({ id: response.body.id, init_point: response.body.init_point });
  } catch (err) {
    console.error("‚ùå Error creando preferencia:", err);
    res.status(500).json({ error: "Error creando pago" });
  }
});

// ===== Webhook para procesar pagos =====

router.post("/webhook", async (req, res) => {
  try {
    const { type, data } = req.body;

    if (type === "payment" && data.id) {
      const { client } = req.app.locals.mercadopago;
      const resp = await client.payment.findById({ id: data.id });

      const { status, transaction_amount: amount, payer } = resp.body;
      const email = payer?.email;

      if (!email) {
        console.warn("‚ö†Ô∏è Pago recibido sin email");
        return res.sendStatus(200);
      }

      const user = await User.findOne({ where: { email } });

      if (user) {
        const now = new Date();
        const nextPaymentDate =
          status === "approved"
            ? new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000) // +30 d√≠as
            : null;

        const blockedPaymentDate =
          status === "approved"
            ? new Date(now.getTime() + (30 + 5) * 24 * 60 * 60 * 1000) // +35 d√≠as
            : null;

        try {
          await Payment.create({
            paymentId: data.id,
            userId: user.id,
            amount,
            status,
            paymentDate: now,
            nextPaymentDate,
            blockedPaymentDate,
            suspense: status === "approved",
            createdAt: now,
            updatedAt: now
          });

          user.suspense = status === "approved";
          await user.save();

          console.log('‚úÖ Pago registrado correctamente:', {
            paymentId: data.id,
            userId: user.id,
            status,
            amount
          });
        } catch (error) {
          if (error.name === 'SequelizeUniqueConstraintError') {
            console.log('‚ÑπÔ∏è Pago ya registrado:', data.id);
          } else {
            throw error;
          }
        }
      } else {
        console.warn("‚ö†Ô∏è Usuario no encontrado para el email:", email);
      }
    }

    res.sendStatus(200);
  } catch (err) {
    console.error("‚ùå Error en webhook:", err);
    res.sendStatus(500);
  }
});

export default router;
